<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HelpScout Test Project - Design Decision & Post-Mortem</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h2 id="design-decision">Design Decision</h2>

<hr>

<p><strong>DECISION 1 : Use Codepipeline as CI/CD provider</strong>  <br>
In order to leverage AWS services and have better integration with the other services.</p>

<blockquote>
  <p><strong>Upside</strong> <br>
  Out of the box integration with GitHub and Jenkins. <br>
  Complex pipeline creation with custom actions is possible</p>
  
  <p><strong>Downside</strong> <br>
  Have minimal integration with other CI/CD providers.  <br>
  Custom action can be complex and takes time to understand. <br>
  ===&gt; <strong>Workaround </strong> Create multiple intermediate instance to handle non-default actions from CodePipeline</p>
  
  <p><strong>Alternative solutions</strong>  <br>
  Use Jenkins or another CI/CD vendor to manage the whole pipeline.</p>
</blockquote>

<hr>

<p><strong>DECISION 2 : Infrastructure Orchestrator</strong>  <br>
Delegate stack creation and minimal server configuration to CloudFormation.</p>

<blockquote>
  <p><strong>Upside</strong> <br>
  All infrastructure specification in one single file. Allow resources referencing with a strong validation system.  <br>
  Handle infrastructure errors &amp; inconsistencies. <br>
  Handle stack update and dependencies. This is the basis for infrastructure as code with infrastructure versioning.</p>
  
  <p><strong>Downside</strong> <br>
  Instance configurations are harder to implement during launch.  <br>
  ===&gt; <strong>Workaround </strong> Delegate instance configurations to a configuration management server like Chef or Opswork.</p>
  
  <p><strong>Alternative solution</strong>  <br>
  Use SDK or API to generate resources</p>
</blockquote>

<hr>

<p><strong>DECISION 3 : Store configuration settings externally</strong> <br>
Store configuration files in GitHub or S3 and pull them based on context.</p>

<blockquote>
  <p><strong>Upside</strong> <br>
  Avoid manual configuration</p>
  
  <p><strong>Downside</strong> <br>
  We have to store the whole context while only some values on specific files are changing.  <br>
  I my specific case, I had to store the files as <em>public</em> resources to avoid cross-account permission management. This is not a good practice <br>
  ===&gt; <strong>Workaround </strong> Only store files that contain the most changing configuration settings.</p>
  
  <p><strong>Alternative solutions</strong>  <br>
  Use a templating system to update only the parts that are changing <br>
  Create standard images and customize them with a configuration management solution (Packer + Chef)</p>
</blockquote>

<hr>

<p><strong>DECISION 4 : Use Elastic Beanstalk as Deployment Provider</strong> <br>
Even if we are using CloudFormation to manage the stack, it remains complex and error-prone. Elastic Beanstalk main purpose is to manage deployments. </p>

<blockquote>
  <p><strong>Upside</strong> <br>
  Remove some complexity in the stack management.  <br>
  Provide an up-to-date environment with automated update management.</p>
  
  <p><strong>Downside</strong> <br>
  It might not be a great fit for complex environment with hundreds of instances and complex networking requirements. <br>
  ===&gt; <strong>Workaround </strong> Use eb configuration files to customize the environment for more complexity.</p>
  
  <p><strong>Alternative solution</strong>  <br>
  Use Opsworks or CloudFormation</p>
</blockquote>

<hr>

<p><strong>DECISION 5 : Self-Testing Server</strong> <br>
Make the servers test themselves and notify the stack orchestrator (CloudFormation) when something is wrong.</p>

<blockquote>
  <p><strong>Upside</strong> <br>
  We stay in the logic of letting the orchestrator manage the infrastructure. CloudFormation will decide if it needs to rollback the stack, send a notification to the administrator or just move forward with the deployment.</p>
  
  <p><strong>Downside</strong> <br>
  If the instance doesn’t reach the testing phase, we won’t know why unless we log into the instance and check logs <br>
  ===&gt; <strong>Workaround </strong> Send logs to cloudwatch with monitoring agent.</p>
  
  <p><strong>Alternative solution</strong>  <br>
  Use an external instance or local machine to perform the tests</p>
</blockquote>

<hr>

<h2 id="post-mortem">Post-Mortem</h2>



<h4 id="1-very-interesting-project">1) Very interesting project</h4>

<p>This was a very interesting project, mainly because of the multiple design possibilities. I could have spent days optimizing the process, trying to implement best practices.  The number of tools and integration possibilities are impressive.</p>

<h4 id="2-easier-with-gui-aws-resources">2) Easier with GUI &amp; AWS Resources</h4>

<p>Setting the pipeline with Cloudformation was straightforward. They have very good tools to create the template and we can create all the operations manually with a GUI called <em>CloudFormation Designer</em>.</p>

<p>Displaying the static page can be done directly with CodePipeline, source from GitHub and pushing to ElasticBeanstalk, which will handle the deployment. However, following my logic of delegating code build/testing to CI tools, I really wanted to integrate Jenkins in the pipeline.</p>

<h4 id="3-challenge-jenkins-instance-standardization">3) Challenge : Jenkins instance standardization</h4>

<p>This is where the challenge begun.</p>

<p>Since this is a central piece in the pipeline, creating a stable Jenkins instance with standard configuration for every deployment was a challenge. It was also a challenge to keep the Jenkins instance consistent for every deployment. Mainly because of the configuration settings and plugins. </p>

<p>My solution of storing the Jenkins jobs files in an S3 Bucket is a hack and is not a scalable solution. I fully understand the benefits of using an image creation framework like Packer and Chef to provision those instances. That way, we could provision multiple custom Jenkins instances to include in our pipeline.</p>

<h4 id="4-challenge-test-driven-infrastructure">4) Challenge : Test-Driven Infrastructure</h4>

<p>The infrastructure testing was my biggest challenge. I found this great tool -Serverspec- which is doing exactly what I want. I then started playing a chicken &amp; egg game, figuring out if I should create a new instance for testing purposes or go with the self testing. </p>

<p>I still think the self-testing logic is the best way to test the “logical” specification even if I wasn’t successful in fully automating it. With more time and stubbornness, I would have found a way to automate the whole testing / self-healing process I had in mind.</p>



<h4 id="4-time-constraints-vs-infinite-optimization">4) Time constraints vs. infinite optimization</h4>

<p>I believe that time constraint is important. Looking for the perfect solution makes us lose time and delay delivery. That is a challenge for me as I am always trying to optimize. I really try to enforce time constraints to force myself to deliver, even if the solution is not perfect.</p>

<h2 id="what-to-improve">What to improve</h2>

<ul>
<li><p>Create multiple Jenkins image with Packer and reference them when I create my instance instead of installing Jenkins from scratch every time. It would be faster and ensure better consistency and remove the need for storing files in S3 bucket.</p></li>
<li><p>Use a template system for configuration files stored in S3. I we could populate the value dynamically when resources are created. This would make the code more modular. I know CloudFormation support <em>Mustache</em>.</p></li>
<li><p>For more complex deployment, I would use CodeDeploy or Opswork instead of ElasticBeanstalk. EB is a great choice for non-complex code.</p></li>
<li><p>I would tighten the security with better IAM roles and policy management. This is currently minimal.</p></li>
<li><p>I would implement a better notification system when the stack is completed. Either using a Lambda function or SNS. This lambda function could then automate the testing process. This would remove the manual process.</p></li>
<li><p>I would add more redundancy for my Jenkins instance. It is currently a single point of failure. </p></li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>I learned a lot and it was fun. You did a great job with this project and I think you will be able to filter through all the required skills. </p>

<p>Good job!</p>

<blockquote>
  <p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p>
</blockquote></div></body>
</html>